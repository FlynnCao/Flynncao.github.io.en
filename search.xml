<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[翻译]JavaScript中的队列、任务、和微任务</title>
      <link href="/2022/04/23/tasks-microtasks-quques-schedule/"/>
      <url>/2022/04/23/tasks-microtasks-quques-schedule/</url>
      
        <content type="html"><![CDATA[<h1 id="翻译JavaScript中的队列、任务、和微任务"><a href="#翻译JavaScript中的队列、任务、和微任务" class="headerlink" title="[翻译JavaScript中的队列、任务、和微任务"></a>[翻译JavaScript中的队列、任务、和微任务</h1><p>原文地址：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p><p>当我告诉我的同事 Matt Gaunt 我正在考虑在浏览器的事件循环中写一篇关于微任务队列和执行的文章时，他说“我跟你说实话，杰克，我不会读那个”。好吧，反正我已经写好了，所以我们都会坐在这里享受它，好吗？</p><p>实际上，如果您更喜欢视频，Philip Roberts 在 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">SConf</a> 上就事件循环发表了精彩的演讲 - 微任务没有被涵盖，但它是对其余部分的一个很好的介绍。不管怎样，我们继续这个话题…</p><p>拿一点点 JavaScript 代码来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>控制台的日志应该以什么顺序出现？</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>正确答案：script start、script end、promise1、promise2、setTimeout，但不同的浏览器会展示出不同的效果。</p><p>Microsoft Edge、Firefox 40、iOS Safari 和桌面 Safari 8.0.8 在 promise1 和 promise2 之前记录 setTimeout - 尽管它似乎是一个竞争条件。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 一直都是正确的。</p><h2 id="为什么这种情况发生了-Why-this-happens"><a href="#为什么这种情况发生了-Why-this-happens" class="headerlink" title="为什么这种情况发生了 Why this happens"></a>为什么这种情况发生了 Why this happens</h2><p>要理解这一点，您需要知道事件循环如何处理任务（task)和微任务(microtask)。第一次遇到它时，这可能会让您大吃一惊。深呼吸…</p><p>每个“线程”都有自己的事件循环，因此每个网页行为都有自己的事件循环，因此它可以独立执行，而<strong>同一源</strong>上的所有窗口都共享一个事件循环，因为它们可以同步通信。事件循环持续运行，执行排在队列中的任务。每个事件循环都有属于他们自己的事件源（如单击按钮执行函数，则这个函数内的事件循环是独立出来的），但是浏览器可以在循环的每一轮中选择从哪个源中获取任务。这允许浏览器优先处理性能敏感的任务，例如用户输入。好吧好吧，我们继续……</p><blockquote><p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 <code>192.168.0.201:8088/index.html</code>和<code>192.168.0.201:8088/login.html</code>就是同源</p></blockquote><p><strong>任务</strong>是经过调度的，因此浏览器可以从其内部进入 JavaScript/DOM 领域，并确保这些操作按顺序发生。在任务之间，浏览器可能会呈现更新。从鼠标点击到事件回调需要安排一个任务，解析 HTML 也是如此，在上面的例子中就是<strong>setTimeout</strong>。</p><p>setTimeout 等待给定的延迟，然后为其回调安排一个新<strong>任务</strong>。这就是为什么在脚本结束后记录 setTimeout 的原因，因为记录脚本结束是第一个任务的一部分，而 setTimeout 记录在一个<strong>单独的任务</strong>中。是的，我们快结束了，但我需要你在接下来的一段时间里保持坚强……</p><blockquote><p>注意，setTimeout的任务和设置触发setTimeout的函数的任务本质上没任何区别 因此他们必须分道扬镳</p></blockquote><p><strong>微任务</strong>通常被安排在当前执行的脚本之后<em>应该立即发生的事情</em>上，例如对一批操作做出反应，或者在不承担全新任务损失的情况下使某些事情异步。只要没有其他 JavaScript 在执行中，并且在每个任务结束时，微任务队列就会在回调之后处理。在微任务期间排队的任何其他微任务都会添加到队列的末尾并进行处理。微任务包括变化观察者（Observer Watcher–Vue中大量使用的）的回调，还有如上例所示的Promise回调。</p><p>一旦 promise 成立，或者如果它已经成立，它就会将一个<strong>微任务</strong>排队等待它的宿主任务回调。这确保了Promise回调是异步的，即使Promise已处于解决状态(fullfilled)。因此，针对已解决的承诺调用 <code>.then(yet, nay) </code>会立即将微任务排入队列。这就是为什么在脚本结束后记录 promise1 和 promise2 的原因，因为当前运行的脚本必须在处理<strong>微任务</strong>之前完成。 promise1 和 promise2 在 setTimeout 之前打印，因为<strong>微任务</strong>总是在下一个<strong>任务</strong>之前发生。</p><p>现在我们来重新审视一下先前的代码…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>是的，没错，我创建了一个动画分步图。你星期六是怎么度过的？和朋友出去晒太阳？嗯，我没有。嗯，如果从我惊人的 UI 设计中看不清楚，请单击上面的箭头前进。</p><blockquote><p>这里建议回原文使用动画来跑一遍代码</p></blockquote><h3 id="为什么一些浏览器不是这样的-了解即可"><a href="#为什么一些浏览器不是这样的-了解即可" class="headerlink" title="为什么一些浏览器不是这样的(了解即可)"></a>为什么一些浏览器不是这样的(了解即可)</h3><p>一些浏览器会在控制台打印Script Start、Script End、setTimeout、promise1、promise2。他们在 setTimeout 之后运行Promise回调。他们很可能将 Promise 回调作为新任务的一部分而不是<strong>微任务</strong>。</p><p>这有点情有可原，因为Promise来自 ECMAScript 而不是 HTML。 ECMAScript 具有类似于<strong>微任务</strong>的“<strong>作业</strong>”概念，但除了模糊的邮件列表讨论之外，这种关系并不明确。然而，普遍的共识是Promise应该是<strong>微任务队列</strong>的一部分，这是有充分理由的。</p><p>将 Promise 视为任务会导致性能问题，因为回调可能会被与任务相关的事情（例如渲染）不必要地延迟）。由于与其他任务源的交互，它还会导致不确定性，并且可能会中断与其他 API 的交互，我们稍后会详细讨论这个。</p><p>这是使用微任务进行Promise的 Edge 证据。 WebKit nightly 正在做正确的事情，所以我认为 Safari 最终会修复它，它似乎在 Firefox 43 中得到修复。</p><p>非常有趣的是，Safari 和 Firefox 在这里都出现了倒退问题，此后已修复。我想知道这是否只是巧合。</p><h2 id="怎么分辨一些东西用了任务还是微任务"><a href="#怎么分辨一些东西用了任务还是微任务" class="headerlink" title="怎么分辨一些东西用了任务还是微任务"></a>怎么分辨一些东西用了任务还是微任务</h2><p>测试是一种方式。查看与 promises 和 setTimeout 相关的日志何时出现，尽管您很依赖正确的结果。</p><p>更好的方法是直接查找细节。例如，setTimeout 的第 14 步将任务排队，而将突变记录排队的第 5 步将微任务排队。</p><p>如前所述，在 ECMAScript 领域，他们将<strong>微任务</strong>称为“<strong>作业</strong>”。在 PerformPromiseThen 的步骤 8.a 中，调用 EnqueueJob 将<strong>微任务</strong>排队。</p><p>现在，我们来看看一个更复杂的例子。这时你心里有个声音会说： “不，我还没有准备好！”。别理他，你已经准备好了。我们来做这个…</p><h2 id="最终决战"><a href="#最终决战" class="headerlink" title="最终决战"></a>最终决战</h2><p>在写这篇文章之前，我已经弄错了。这是一些html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给定下面的 JS，如果我点击 div.inner 会打印什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let&#x27;s get hold of those elements</span></span><br><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.outer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let&#x27;s listen for attribute changes on the</span></span><br><span class="line"><span class="comment">// outer element</span></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mutate&#x27;</span>);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  <span class="attr">attributes</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s a click listener…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">&#x27;data-random&#x27;</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …which we&#x27;ll attach to both elements</span></span><br><span class="line">inner.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br><span class="line">outer.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br></pre></td></tr></table></figure><p>继续，在查看答案之前先试一试。提示：日志可以发生不止一次。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>单击inner的时候</p><p>click<br>promise<br>mutate<br>click<br>promise<br>mutate<br>timeout<br>timeout</p><p>单击outer的时候</p><p>click<br>promise<br>mutate<br>timeout</p><blockquote><p>你的猜测不一样吗？如果是这样，您可能仍然是对的。有的浏览器中可能效果不一致，以Chrome浏览器为标准答案</p></blockquote><h2 id="谁是对的？-Who’s-Right"><a href="#谁是对的？-Who’s-Right" class="headerlink" title="谁是对的？ Who’s Right"></a>谁是对的？ Who’s Right</h2><p>调度 ‘click’ 事件是一项任务。变异观察者(Mutation Observer)和Promise回调被视为<strong>微任务</strong>并排队。 setTimeout 的回调被视为<strong>任务</strong>并排队。</p><blockquote><p>这里建议回原文使用动画来跑一遍代码</p></blockquote><p>在每一次侦听器回调结束后…</p><blockquote><p>如果脚本设置对象堆栈现在为空，则执行微任务检查点<br>— HTML：回调步骤 3 后的清理</p></blockquote><p>以前，这意味着微任务在侦听器回调之间运行，但 .click() 导致事件同步调度，因此调用 .click() 的脚本仍在回调之间的堆栈中。上述规则确保微任务不会中断正在执行的 JavaScript。这意味着我们不会在侦听器回调之间处理微任务队列，而是在两个侦听器之后处理它们。</p><h2 id="这些重要吗"><a href="#这些重要吗" class="headerlink" title="这些重要吗"></a>这些重要吗</h2><p>作者在这里聊了聊之前遇到的bug，建议大家用最新版本的浏览器调试，屁事没有</p><h2 id="你做到了！"><a href="#你做到了！" class="headerlink" title="你做到了！"></a>你做到了！</h2><p>总结：</p><ul><li><strong>任务</strong>按顺序执行，但是浏览器可能会在两个任务之间<strong>重渲染</strong>网页</li><li><strong>微任务</strong>按顺序执行，且在以下情况下执行：<ul><li>每次回调函数结束后，只要没有JS代码在执行中</li><li>每次<strong>任务</strong>结束后</li></ul></li></ul><p>希望你现在按照自己的方式理解了事件循环（event loop），至少知道如何去做或者如何躺平。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git、NPM、Maven、PIP加速下载</title>
      <link href="/2022/04/17/node-github-pip-proxy-setting/"/>
      <url>/2022/04/17/node-github-pip-proxy-setting/</url>
      
        <content type="html"><![CDATA[<h1 id="Git、NPM、Maven、PIP加速下载"><a href="#Git、NPM、Maven、PIP加速下载" class="headerlink" title="Git、NPM、Maven、PIP加速下载"></a>Git、NPM、Maven、PIP加速下载</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>直接在<strong>终端</strong>命令行键入命令<br>代理：</p><pre class="line-numbers language-none"><code class="language-none">git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>端口号根据情况自行修改 </p></blockquote><p>取消代理：</p><pre class="line-numbers language-none"><code class="language-none">git config --global --unset http.proxygit config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>使用淘宝镜像加速下载</p><pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>找到Maven的安装目录，如<code>D:\Program Files\apache-maven-3.6.3</code>在旗下的<code>conf</code>目录中找到<code>settings.xml</code>，如果没有新建一个<br>复制或者修改内容为：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/SETTINGS/1.0.0<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/SETTINGS/1.0.0                         https://maven.apache.org/xsd/settings-1.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interactiveMode</span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>offline</span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginGroups</span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servers</span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>nexus-aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">&gt;</span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>Nexus aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://maven.aliyun.com/nexus/content/groups/public<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrors</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeProfiles</span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PIP"><a href="#PIP" class="headerlink" title="PIP"></a>PIP</h2><p>将包下载地址更换为国内源 (Windows)</p><p>C:\Users\用户\xx\AppData\Roaming  这里的xx指代的是你电脑的登录的用户名</p><p>进入pip文件夹，创建pip.ini文件，内容如下</p><pre class="line-numbers language-none"><code class="language-none">[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尝试过后，如果报以下错误</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">pip is configured <span class="token keyword">with</span> locations that require <span class="token constant">TLS</span><span class="token operator">/</span><span class="token constant">SSL</span><span class="token punctuation">,</span> however the ssl module <span class="token keyword">in</span> Python is not available<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则需要安装一个文件 <a href="https://slproweb.com/products/Win32OpenSSL.html">https://slproweb.com/products/Win32OpenSSL.html</a></p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/denfaxelgl.png" alt="img"></p><p>点击EXE下载安装后，再次尝试，即可成功</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1761837">https://cloud.tencent.com/developer/article/1761837</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> common </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win11试用体验</title>
      <link href="/2021/10/17/win11-first-experience/"/>
      <url>/2021/10/17/win11-first-experience/</url>
      
        <content type="html"><![CDATA[<h1 id="WIN11-试用体验"><a href="#WIN11-试用体验" class="headerlink" title="WIN11 试用体验"></a>WIN11 试用体验</h1><p>没想到啊没想到，2021年微软终于把Office上的设计理念搬到了系统上，终于不是那么人不像人鬼不像鬼了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装起来还是很简单的，当然你需要先下载一个监测工具来监测你有没有安装资格..</p><p><a href="https://www.microsoft.com/zh-cn/windows/get-windows-11?r=1">https://www.microsoft.com/zh-cn/windows/get-windows-11?r=1</a></p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20220419142138625.png" alt="image-20220419142138625"></p><p>GG。文章结束</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs+MongoDB+EXpressjs</title>
      <link href="/2021/10/01/nodejs-basic-oneline/"/>
      <url>/2021/10/01/nodejs-basic-oneline/</url>
      
        <content type="html"><![CDATA[<h1 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>特点：</p><pre><code>* Nodejs是一个开源、跨平台、独立于浏览器外的JavaScript**后端**运行环境* 事件驱动、异步I/O、单进程* **服务端**的环境* 基于Google的V8引擎</code></pre><p>有什么用：</p><ul><li>创建应用服务</li><li>基于后端的web开发</li><li>接口开发（小程序开发）</li><li>客户端应用程序gulp、webpack、react/vue脚手架、小程序启动环境</li></ul><p>模块化：（一个js文件就是一个模块）</p><ul><li>内置模块-自带库</li><li>第三方模块-手动通过npm,yarn来进行安装</li><li>自定义模块（自己开发）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports / <span class="built_in">exports</span> <span class="comment">//导出</span></span><br><span class="line">rquire(<span class="string">&#x27;module_name&#x27;</span>) <span class="comment">//导入</span></span><br></pre></td></tr></table></figure><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2 入门"></a>2 入门</h2><h3 id="2-1-运行js文件"><a href="#2-1-运行js文件" class="headerlink" title="2.1 运行js文件"></a>2.1 运行js文件</h3><p><code>node - v</code>监测node版本</p><p><code>node JS文件路径</code></p><blockquote><p>文件路径<code>./</code>相对于当前路径；<code>../</code>相对于上一层路径；<code>/</code>Linux系绝对路径；<code>C:/</code>Win系绝对路径</p></blockquote><h3 id="2-2-全局变量"><a href="#2-2-全局变量" class="headerlink" title="2.2 全局变量"></a>2.2 全局变量</h3><ul><li>global 全局变量的宿主（类似于浏览器的window对象）这是一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问。</li><li>__filename：当前正在执行的脚本的文件名</li><li>__dirname：当前正在执行脚本所在的目录</li></ul><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210903230100874.png" alt="image-20210903230100874"></p><h2 id="3-内置常用模块"><a href="#3-内置常用模块" class="headerlink" title="3 内置常用模块"></a>3 内置常用模块</h2><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>提供了于操作系统相关的实用方法和属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>) <span class="comment">//从node库中导入os模块</span></span><br><span class="line"><span class="built_in">console</span>.log(os.EOL); <span class="comment">//换行 == end of line</span></span><br><span class="line"><span class="built_in">console</span>.log(os.cpus()) <span class="comment">//查看cpu相关信息</span></span><br><span class="line"><span class="built_in">console</span>.log(os.totalmem()) <span class="comment">//总内存</span></span><br><span class="line"><span class="built_in">console</span>.log(os.freemem()) <span class="comment">//剩余内存</span></span><br><span class="line"><span class="built_in">console</span>.log(os.hostname()) <span class="comment">//主机名</span></span><br><span class="line"><span class="built_in">console</span>.log(os.type()) <span class="comment">//操作系统类型</span></span><br></pre></td></tr></table></figure><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><p>path模块主要用于处理文件和目录的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> file = <span class="string">&#x27;D:\\Program Files\\PicGo\\LICENSE.electron.txt&#x27;</span>;</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(file)); <span class="comment">//-&gt;LICENSE.electron.txt</span></span><br><span class="line"><span class="comment">//获取路径</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(file)); <span class="comment">// -&gt; D:\Program Files\PicGo</span></span><br><span class="line"><span class="comment">//获取拓展名</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(file)); <span class="comment">//-&gt; .txt</span></span><br><span class="line"><span class="comment">//使用指定的分割符将片段拼接为路径名</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)) <span class="comment">// -&gt; \a\b\c</span></span><br><span class="line"><span class="comment">//在根目录下使用指定的分割符将片段拼接为路径名，windows下追加盘符</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)) <span class="comment">// -&gt; D:\a\b\c</span></span><br></pre></td></tr></table></figure><blockquote><p>在windows环境下，正斜杠<code>/</code>会转化为反斜杠<code>\</code>随便用，Linux环境下，不要使用反斜杠`</p></blockquote><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><p>url字符串是结构化的字符串，包含多个含义不同的组成成分。解析字符串后返回的URL字符串，每个属性对应字符串的各个组成部分。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210904213258567.png" alt="地址构成图"></p><p>同源策略：协议相同、主机名+端口相同</p><p>常用接口：</p><ul><li>url.parse(‘XXX’,true)  方法接受网址字符串，解析并返回网址对象 -query参数为对象形式</li><li>url.parse(‘XXX’) 方法接受网址字符串，解析并返回网址对象。-query参数为字符串形式</li><li>url.resolve(‘XXX1’,’XXX2’)  以XXX1基本网址解析XXX2，返回解析好的网址</li></ul><h3 id="querystring模块"><a href="#querystring模块" class="headerlink" title="querystring模块"></a>querystring模块</h3><p>用于解析和格式化URL查询字符串（get传参）的实用工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(querystring.parse(<span class="string">&#x27;username=zhangsan&amp;age=22&amp;gender=m&#x27;</span>)); </span><br><span class="line"><span class="comment">// -&gt; &#123;username: &#x27;zhangsan&#x27;,age: &#x27;22&#x27;,gender: &#x27;m&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring.stringify(&#123;<span class="attr">username</span>: <span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span>,<span class="attr">gender</span>: <span class="string">&#x27;m&#x27;</span>&#125;));</span><br><span class="line"><span class="comment">//-&gt;username=zhangsan&amp;age=22&amp;gender=m</span></span><br></pre></td></tr></table></figure><blockquote><p>querystring.decode = querystring.parse;querystring.encode= querystring.stringify。但实际使用中以parse和stringfy居多</p></blockquote><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><p>fs(file system)模块提供了用于与文件进行交互的相关方法。</p><blockquote><p>fs提供了两大类api，同步操作和异步操作，默认为异步操作，如果是同步名字会加上<strong>sync</strong>后缀</p></blockquote><blockquote><p>异步的特点是有回调函数，方便异步进程结束后调用</p></blockquote><p>准备：在D:/hello目录下新建一个01.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指定内容异步写入文件，覆盖原内容</span></span><br><span class="line">fs.writeFile(<span class="string">&#x27;D:/hello/2004.txt&#x27;</span>, <span class="string">&#x27;hello 2004&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); </span><br><span class="line">    <span class="comment">//-&gt;null </span></span><br><span class="line">    <span class="comment">//-&gt;[Error: ENOENT: no such file or directory, open &#x27;X:\hello\2004.txt</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//读文件内容</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;D:/hello/2004.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data); <span class="comment">//-&gt;hello 2004</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">//同步判断文件是否存在</span></span><br><span class="line"><span class="keyword">const</span> dir = <span class="string">&#x27;D:/hello/2004.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dir2 = <span class="string">&#x27;D:/hello/2021.txt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fs.existsSync(dir)); <span class="comment">//-&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(fs.existsSync(dir2)); <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="comment">//读取文件信息</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    fs.stat(<span class="string">&#x27;D:/hello/2004.txt&#x27;</span>, <span class="function">(<span class="params">err1, stats</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!err1)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(stats)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">1000</span>) <span class="comment">//-&gt; 。。。</span></span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    fs.unlink(<span class="string">&#x27;D:/hello/2004.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><blockquote><p>writeFile方法会自动创建文件，如果文件存在则执行覆盖</p></blockquote><blockquote><p>因为写入文件是异步操作，为了能准确地读取到文件的信息，这里使用了setTimeout创建了一个task（主线程结束之后才运行）</p></blockquote><blockquote><p>因为创建文件是异步操作，为了能准确删除文件，这里延迟两秒之后才删除</p></blockquote><p>解决回调地狱的方法：</p><ul><li>1.使用promise对象以及async、await关键字</li><li>2.使用同步方法</li></ul><h3 id="http模块-heart"><a href="#http模块-heart" class="headerlink" title="http模块  :heart:"></a>http模块  :heart:</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Web服务器一般指的是<strong>网站服务器</strong>（服务器：给用户提供服务的机器就是服务器），是指驻留在因特网上某一台或N台计算机的程序，可以处理浏览器等Web客户端的请求并返回相关响应。在服务器上还需要安装服务器安装软件，目前主流的三大Web服务器软件是<strong>Apache</strong>、<strong>Nginx</strong>和<strong>IIS</strong>。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210905002424547.png"></p><h4 id="传统开发与前后端分离"><a href="#传统开发与前后端分离" class="headerlink" title="传统开发与前后端分离"></a>传统开发与前后端分离</h4><ul><li>传统开发（前后端耦合开发）</li></ul><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210905003514504.png" alt="image-20210905003514504"></p><ul><li><p>前后端分离开发</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210905003523727.png"></p></li></ul><h4 id="服务器相关概念"><a href="#服务器相关概念" class="headerlink" title="服务器相关概念"></a>服务器相关概念</h4><ul><li><p>ip地址：ip地址有v4和v6两种，IP地址就是互联网上每台计算机/电子设备的唯一地址，因此IP地址具有唯一性。在开发期间，自己的电脑是一台服务器，也是一个客户端，本机的IP地址为127.0.0.1。</p></li><li><p>域名：因为IP地址不够直观而发明的字符型地址方案，叫做域名地址。IP地址和域名是一一对应的关系，对应关系存在DNS服务器中，本机的域名为localhost。</p></li></ul><blockquote><p>本地键入localhost如果无法使用，则可能是本机的host文件没匹配ip地址</p></blockquote><ul><li>网路协议：不同的计算机之间必须使用相同的网络协议才能进行通信。如：TCP、UDP、HTTP、FTP等等。</li><li>端口号：在一台电脑中，可以运行N个多个web服务。每个web服务都对应唯一的一个端口号。客户端发过来的网络请求，通过端口号，可以准确地交给对应的web服务进行处理。http默认端口号为80。https的默认端口为443。</li></ul><blockquote><p>常见的端口号分别占用:20 21 22 25 80 443 3306 3389 11211 27017… </p></blockquote><h4 id="创建Web服务器"><a href="#创建Web服务器" class="headerlink" title="创建Web服务器"></a>创建Web服务器</h4><p>request和response:</p><ul><li>request：接受客户端请求对象，包含了与客户端相关的数据和属性<ul><li>request.url 客户端请求的url地址</li><li>request.method 客户端请求的方式 get或post</li><li>request.headers 客户端请求头信息对象</li></ul></li><li>response：服务端对客户端的响应对象<ul><li>request.setHeader 设置响应头</li><li>request.statusCode 设置状态码</li><li>request.end 向客户端发送响应数据，并结束请求过程</li></ul></li></ul><p>服务器搭建过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">//创建web服务对象实例</span></span><br><span class="line"><span class="keyword">const</span> server  = http.createServer();</span><br><span class="line"><span class="comment">//绑定监听客户端request请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">&#x27;/&#x27;</span>)&#123; </span><br><span class="line">        res.end(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url === <span class="string">&#x27;/2020&#x27;</span>)&#123; </span><br><span class="line">        res.end(<span class="string">&#x27;ConVirus&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8088</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is running at http://127.0.0.1:8080/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h4><ul><li><p>静态资源：html、css、js、图片、视频、音频等</p></li><li><p>专门保存上述资源的服务器，称为静态资源服务器</p></li><li><p>实现思路：客户端请求的每个资源url地址，作为在本机服务器中指定目录的文件。通过相关模块进行读取文件数据进行响应给客户端，从而实现静态服务器</p></li></ul><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210905172441003.png" alt="image-20210905172441003"></p><p>普通html文件的响应头设置<code>res.setHeader(&#39;Content-Type&#39;, &#39;image/jpeg;charset=&quot;utf-8&quot;&#39;)</code></p><p>图片的响应头设置：<code>res.setHeader(&#39;Content-Type&#39;, &#39;image/jpeg;charset=&quot;utf-8&quot;&#39;)</code></p><blockquote><p>其余各种格式的响应头可以参考 <a href="https://www.runoob.com/http/http-content-type.html">HTTP content-type | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="get数据获取"><a href="#get数据获取" class="headerlink" title="get数据获取"></a>get数据获取</h4><p>get数据通过地址栏通过query方式进行传递数据 例如<code>?id=1313&amp;name=lizang&amp;age=22</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    <span class="keyword">if</span>(req.url !== <span class="string">&#x27;/favicon.ico&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;query&#125; = url.parse(req.url, <span class="literal">true</span>); <span class="comment">//解构赋值获取</span></span><br><span class="line">        <span class="built_in">console</span>.log(query);</span><br><span class="line">        <span class="comment">//输出具体的数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>,query.id);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>,query.name);</span><br><span class="line">        res.end(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8082</span>);</span><br></pre></td></tr></table></figure><h4 id="post数据获取"><a href="#post数据获取" class="headerlink" title="post数据获取"></a>post数据获取</h4><p>表单数据多为post进行提交到服务器。需要监听req对象的data事件来获取客户端发送到服务器的数据。如果数据量比较大， 无法一次发送，则客户端会把数据切割后再分批次发送给服务器。所以data事件可能会被触发多次，每次触发data事件时，收到的数据只是全部数据的一部分，因此需要做数据的拼接才能得到完整的数据。</p><p>搭建post服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querstring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">http.createServer((<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">//监听数据接受中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(buffer);</span><br><span class="line">        arr.push(buffer);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听数据传输结束</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> buffers = Buffer.concat(arr);</span><br><span class="line">        <span class="comment">//将缓冲区的累计结果转化为对象</span></span><br><span class="line">        <span class="keyword">let</span> post = querstring.parse(buffers.toString());</span><br><span class="line">        <span class="built_in">console</span>.log(post);</span><br><span class="line">        res.end(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)).listen(<span class="number">8083</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is running at 8083&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210905213154461.png" alt="image-20210905213154461"></p><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server is running at 8083</span><br><span class="line">&lt;Buffer 6e 61 6d 65 3d 74 6f 6e 79 26 61 67 65 3d 31 31 26 71 71 3d 31 32 33&gt;</span><br><span class="line">[Object: null prototype] &#123; name: &#x27;tony&#x27;, age: &#x27;11&#x27;, qq: &#x27;123&#x27; &#125;</span><br></pre></td></tr></table></figure><h1 id="Expressjs"><a href="#Expressjs" class="headerlink" title="Expressjs"></a>Expressjs</h1><p>express是基于nodejs第三方包，用于快速搭建“Web服务器”。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建Web服务"><a href="#创建Web服务" class="headerlink" title="创建Web服务"></a>创建Web服务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//创建web服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//监听get请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.listen(<span class="number">8181</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is running at 8081&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p> 在Windows平台下可以使用<code>netstat -ano | findStr 8080</code> 来查看指定端口是否有效 </p></blockquote><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>使用postman等测试工具对访问进行调试。</p><p>现代的前后端分离开发模式中，常见的增删改查分的更细化：</p><ul><li>GET 查询请求（地址栏传参）:mag:</li><li>POST 新增请求（请求体传参）:heavy_plus_sign:</li><li>PUT 修改请求（地址栏传参+请求体传参）:fork_and_knife:</li><li>DELETE 删除请求（地址栏传参）:no_pedestrians:</li></ul><p>这种对请求方法（动词）加以约束的规范叫做<code>restful</code>规范。该规范不是硬性要求，但是接口设计的时候一般会遵守，该规范不仅仅是请求方式，在请求地址、响应状态码等方面也存在规范要求。</p><blockquote><p>在Express中，符合<code>restful</code>规范的请求动词也是被支持的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//创建web服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//监听get请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello get&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, (<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello post&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line">app.put(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;hello put&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.delete(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;hello delete&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.listen(<span class="number">8181</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is running at 8081&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210909233143746.png"></p><blockquote><p>[不推荐]如果有请求地址都一样，但是支持所有类型的操作，则可以使用<code>app.all(&#39;/XXX&#39;,(req,res)=&gt;&#123;&#125;)</code>； 推荐把功能接口分清楚</p></blockquote><h3 id="query字符串和动态参数"><a href="#query字符串和动态参数" class="headerlink" title="query字符串和动态参数"></a>query字符串和动态参数</h3><p><strong>query参数：</strong></p><p>在监听各种方法的请求中使用<code>request.query</code>来查看用户访问的串。</p><p><strong>动态参数：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.delete(<span class="string">&#x27;:/id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//举例：必须的路由参数，不传会报错，显示404</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id);</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;:/id?&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//举例：非必须的路由参数，不传不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这种监听方式是符合restful规范的</p></blockquote><p>举例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.put(<span class="string">&#x27;/user/:id/&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id); </span><br><span class="line">    res.end(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在地址栏输入<code>http://127.0.0.1:8181/user/1379</code>，后端控制台打印<code>1379</code></p><blockquote><p>如果这里不传/1379，则浏览器返回<code>Cannot PUT /user</code>-&gt;404 not found</p><p>如果监听的时候是<code>/user/:id?</code>则浏览器正常返回done</p></blockquote><h3 id="静态服务托管"><a href="#静态服务托管" class="headerlink" title="静态服务托管"></a>静态服务托管</h3><p>express提供了<code>express.static()</code>来非常方便地创建一个静态资源服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//创建web服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8181</span>;</span><br><span class="line"><span class="comment">//静态资源服务器</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line"><span class="comment">//public代表根目录中静态资源文件的位置</span></span><br><span class="line"><span class="comment">//use方法将会传入一个中间件函数</span></span><br><span class="line">app.listen(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;listing port on 8181&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接使用<code>http://localhost:8181/3.jpeg</code>来访问public目录下的文件</p><p>:tada:加入路径来混淆实际地址或者资源区分</p><p><code>app.use(&#39;/static&#39;,express.static(&#39;public&#39;));</code></p><p>则需要使用<code>http://localhost:8181/static/3.jpeg</code>来访问静态资源</p><blockquote><p>app.use：使用一个中间件，绝大部分需要写在监听请求方法之前</p></blockquote><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>路由在生活中如拨打电话的时候，会按照数字几处理什么样的服务，他就是类似于按键与服务之间的映射关系。在Express中，路由指的是客户端发起的请求与服务器端处理方法之间的映射关系。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210919163610074.png" alt="image-20210919163610074"></p><h3 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h3><p>express中的路由分三部分组成，分别是请求类型（方法），请求uri和对应的处理函数。</p><p>当一个客户端请求到达服务端之后，先经过路由规则匹配，只有经过匹配成功以后，才会调用对应的处理函数。在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的函数进行处理。</p><p><code>app.&lt;get/post/put/delete&gt;(uri,(req,res)=&gt;&#123;&#125;)</code></p><blockquote><p>use方法并不是请求类型</p></blockquote><h3 id="路由模块化-heart"><a href="#路由模块化-heart" class="headerlink" title="路由模块化 :heart:"></a>路由模块化 :heart:</h3><p>含义：</p><p>将路由进行模块化，以模块（js文件）为单位进行管理，物以类聚。</p><p>核心思想：</p><p>能拆就拆。</p><p>具体做法：</p><p>按照功能进行区分，如用户一个、新闻一个、商品一个（而不是方法）</p><p>再开发项目时，如果将所有的路由规则都挂载在入口文件中，程序编写和维护都变得非常困难。所以express为了路由的模块化管理，通过express.Router()方法创建路由模块化管理的程序，可以将不同业务需求分开到不同的模块中，从而便于代码和的维护的项目拓展。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210919163610074.png"></p><p>步骤：</p><ol><li>创建独立Js空白文件（最后统一放在一个目录下）</li><li>在第一个js文件中使用express.Router() 方法创建路由模块文件</li><li>使用路由对象完成路由规则的对应的业务编写。</li><li>使用模块化导出。module.exports = router</li><li>在主入口文件中能够使用app.use方法来注册定义的路由模块。</li></ol><blockquote><p>app.use(‘XXX’, 路由模块)  ： XXX为跳转路由时自动追加的前缀</p></blockquote><h2 id="中间件-heart"><a href="#中间件-heart" class="headerlink" title="中间件 :heart:"></a>中间件 :heart:</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>中间件（middleware)可以理解为业务流程中的中间处理环节。</p><blockquote><p>本质就是一个函数</p></blockquote><p>express中，当一个请求到达服务器之后，可以在给用户响应之前连续调用多个中间件，来对本次请求和返回响应数据进行处理。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20211006224129744.png" alt="image-20211006224129744"></p><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><p>主要有：</p><ul><li>内置中间件</li><li>第三方中间件</li></ul><p>非expess官方内置的第三方的中间件。如body-parser</p><ul><li>自定义中间件<img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20211006224129744.png"><ul><li>应用级别<code> app.use</code>（全局） <code>app.请求方法(地址,中间件,回调函数)</code> （局部）</li><li>路由级别 <code>router.use</code>  <code>router.请求方法(地址,中间件,回调函数)</code> </li></ul></li></ul><h3 id="内置中间件-（4-16"><a href="#内置中间件-（4-16" class="headerlink" title="内置中间件 （4.16+)"></a>内置中间件 （4.16+)</h3><p>express提供了很好用的内置中间件，如提供一个静态资源管理的中间件，通过此中间件能帮助我们快速搭建一个静态资源管理器。</p><p><code>app.use(‘前缀&#39;, express.static(&#39;托管目录地址&#39;))</code></p><p>在express中，除了内置的<code>express.static()</code>中间件，还内置了另外2个常用的中间件。</p><ul><li>express.json</li></ul><p>作用：接受json格式提交的数据</p><p>使用方法：<code>app.use(express.json())</code></p><p><strong>其在接受完数据之后，会将数据的对象形式挂载到<code>req</code>请求对象的body属性上。</strong>直接用控制台可以输出。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20211017221817062.png" alt="image-20211017221817062"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &#x27;body&#x27;, age: &#x27;123&#x27; &#125;</span><br></pre></td></tr></table></figure><ul><li>express.urlencoded</li></ul><p>作用：处理post表单数据</p><p>使用方法：<code>app.use(express.urlencoded)&#123;extended:false&#125;</code></p><blockquote><p>extend:false 要求在解析数据时使用querystring库（踢出传递过来的方法和对象，只保留基本类型），否则&lt;默认&gt;为qs库</p></blockquote><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20211017190517159.png" alt="image-20211017190517159"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Object: null prototype] &#123; name: &#x27;tony&#x27;, age: &#x27;11&#x27;, qq: &#x27;123&#x27; &#125;</span><br></pre></td></tr></table></figure><p><strong>其在接受完数据之后，会将数据的对象形式挂载到<code>req</code>请求对象的body属性上。</strong></p><p>以上这两个中间件都是全局中间件。</p><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>本质上就是定义一个处理请求的函数，此函数出了request和response之外，还需要有一个next参数。此参数作用让程序继续执行，直到匹配到合适的路由中发送响应体给服务器端。</p><p><strong>所有中间件公用一个req和res</strong></p><h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><h3 id="错误类型中间件"><a href="#错误类型中间件" class="headerlink" title="错误类型中间件"></a>错误类型中间件</h3><h4 id="中间件的局部使用"><a href="#中间件的局部使用" class="headerlink" title="中间件的局部使用"></a>中间件的局部使用</h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue权限管理实战（挖坑）</title>
      <link href="/2021/09/20/vue-project-permissions/"/>
      <url>/2021/09/20/vue-project-permissions/</url>
      
        <content type="html"><![CDATA[<h1 id="vue权限管理实战"><a href="#vue权限管理实战" class="headerlink" title="vue权限管理实战"></a>vue权限管理实战</h1><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210920224042309.png" alt="image-20210920224042309"></p><p>首先在vuex中存储了当前登录用户的<strong>权限</strong>状态，使用计算属性导出之</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">roles</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>roles<span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> getters<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>permission是一个自定义vue指令，我们在后期会命名为<code>vue-permissions</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'@/store'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'el :&gt;&gt; '</span><span class="token punctuation">,</span> el<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'binding :&gt;&gt; '</span><span class="token punctuation">,</span> binding<span class="token punctuation">)</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> binding <span class="token comment">// 从binding中取得值</span>    <span class="token keyword">const</span> roles <span class="token operator">=</span> store<span class="token punctuation">.</span>getters <span class="token operator">&amp;&amp;</span> store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>roles <span class="token comment">//从vuex读取当前角色的权限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> value <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> permissionRoles <span class="token operator">=</span> value <span class="token comment">//</span>        <span class="token keyword">const</span> hasPermission <span class="token operator">=</span> roles<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">role</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> permissionRoles<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>role<span class="token punctuation">)</span> <span class="token comment">// 检查是否有这个角色</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasPermission<span class="token punctuation">)</span> <span class="token punctuation">{</span>          el<span class="token punctuation">.</span>parentNode <span class="token operator">&amp;&amp;</span> el<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">使用方式： v-permission="['admin','editor']"</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先直接看一段v-permission传入的信息举例：</p><p><code>crud-permission</code>是导入crud的子组件，他的地址在</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210920225421289.png" alt="image-20210920225421289"></p><p><code>curd.operation.vue</code>封装了常用的新增、修改、删除操作，还提供了左右插槽，具体页面体现在</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210920230033537.png" alt="image-20210920230033537"></p><p>另外还提供了搜索、刷新、删除的操作</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>也谈苹果2021.9新品发布会</title>
      <link href="/2021/09/15/apple-conference-2021/"/>
      <url>/2021/09/15/apple-conference-2021/</url>
      
        <content type="html"><![CDATA[<h1 id="也谈苹果2021-9新品发布会"><a href="#也谈苹果2021-9新品发布会" class="headerlink" title="也谈苹果2021.9新品发布会"></a>也谈苹果2021.9新品发布会</h1><p>作为一个老年人还是和往年一样凌晨1点钟准时蹲在电视机前（不对是电脑前）观看一年一度的科技界春晚—Apple秋季发布会，看吧觉得没什么好看的 不看吧又觉得少点什么，人真是奇怪的动物。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915225701447.png" alt="image-20210915225701447"></p><p>不得不说，库克的美语讲的很让人舒服，整场发布会下来是很令人轻松愉悦的英语听力材料。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915225806480.png" alt="image-20210915225806480"></p><p>先补一个在中国完全用不了的AppleTV，当然还有后面的Fitness+，哦还有吹了很多年的Arcade，这种东西就算开放了国内也没多少人去买吧…不过尤其Apple TV+ 就算不是网飞或HBO之流对于国内的已经是降维打击了，然而广电…</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915230108044.png" alt="image-20210915230108044"></p><p>接下来是ipad9，也就是入门款的iPad。都2021年了还在用一代笔是不是有点寒酸了，当然一代笔质量并不差。我吃灰的ipad2018书写体验并不赖，配上类纸膜之类的黑科技几乎可以媲美手写了。A13肯定是够用的，主打教育市场也没什么好吐槽的。能配合普通的智能键盘（RMB1239），还行。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915230341097.png" alt="image-20210915230341097"></p><p>小款的iPad mini也更新了，参见最强游戏机！比较坑的一点是只有64GB和256GB，这样下来也得4999了，不算便宜。不过这个配置（A15+4GB RAM）确实可以用上很多年。而且A15可是满血版的A15，平板的散热加上续航加上5G，体验会非同一般的好。🍕爆款预警</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915230644138.png" alt="image-20210915230644138"></p><p>接下来是Apple Watch，作为一个我一直在观望而从未接触过的产品。没有预料到他已经发展了这么多代了，Apple Watch已经从一个普通的智能手表变成了健康运动界的智能设备先驱🚩确实挺厉害的。S7目前看来没有什么升级，有钱了我也买一个吧，问就是为了健康和自律😀</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231002240.png" alt="image-20210915231002240"></p><p>主角终于来了！iPhone</p><p>虽然每次发布会前都会爆料不少，但还是希望有一点点惊喜</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231157216.png" alt="image-20210915231157216"></p><p>这次iPhone13的蓝色…比12正常太多了！12那廉价的蓝色一度登上热搜。13相对于12除了处理器的升级其他的都是微乎其微。cinematic mode（电影模式）倒是挺有意思的，这样自己和朋友拍个小短片也会很有趣。不过真·业余摄影爱好者还是会上pro吧~😀</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231336469.png" alt="image-20210915231336469"></p><p>这个MagaSafe确实挺有意思，但是充电功率实在是太！低！了！</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231737462.png" alt="image-20210915231737462"></p><p>安卓上已经50 60 70甚至上百W的充电，苹果这里只有可怜的15w，还美其名曰保护电池。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231707843.png" alt="image-20210915231707843"></p><p>接下来是重头戏iPhone13 Pro。这个Pro可以说是非常Pro。</p><p>首先满血A15比A14的GPU性能提升了50%，而残血版（13上的）只提升了30%，过两天媒体机出来了应该会有很详细的测评。</p><blockquote><p>补一个个人觉得非常漂亮的远山蓝色</p></blockquote><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915231923622.png" alt="image-20210915231923622"></p><p>另外最妙的当然是120Hz自适应高刷新率，高刷这个东西确实是用了就回不去了。我就一台144hz的显示器都是丝滑顺畅，何况是每天都在滑的手机呢。很期待和iOS动画结合完全的ProMotion。</p><p>希望能确保官方标称续航的情况下发挥高刷，那样的话就太完美了。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915232232699.png" alt="image-20210915232232699"></p><p>本年度最好的视频影像系统（注意定语），一年拍不了几次照片的我当然感知不强。不过当年6s拍出来的视频质量已经让我感到十分惊艳（比拍照还给力就挺奇怪的）。过了这么多年….等等，13 pro不会成为新一代钉子户吧？拭目以待。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915232454858.png" alt="image-20210915232454858"></p><p>又到了👴最喜欢的价格环节，看价格上这次价格没有变，但是！人民币最近升值让13全系比12全息发布的时候便宜了近800元，这个就很喜闻乐见了。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210915232607356.png" alt="image-20210915232607356"></p><p>那么古尔丹，双11销量皇帝是谁呢？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[翻译]PromiseA+</title>
      <link href="/2021/09/15/promisea-plus/"/>
      <url>/2021/09/15/promisea-plus/</url>
      
        <content type="html"><![CDATA[<h1 id="翻译-Promises-A-规范"><a href="#翻译-Promises-A-规范" class="headerlink" title="[翻译]Promises/A+规范"></a>[翻译]Promises/A+规范</h1><blockquote><p> 原文地址：<a href="https://promisesaplus.com/">https://promisesaplus.com/</a></p></blockquote><p>一个健全的、可互操作的 JavaScript Promise的开放标准——由实施者提供，为实施者服务。</p><p>Promise代表了异步操作的最终结果。与Promise交互的最主要方式是通过<code>then</code>方法，该方法注册回调以接收Promise的最终值或者无法实现的原因。</p><p>这个规范详细说明了 then 方法的行为，提供了一个可互操作的基础，所有符合 Promises/A+ 的承诺实现都可以依赖该基础来提供。因此，规范应该被认为是非常稳定的。尽管 Promises/A+ 组织可能偶尔会通过向后兼容的微小更改来修改此规范以解决新发现的极端情况，但只有经过仔细考虑、讨论和测试后，我们才会集成大的或向后不兼容的更改。</p><p>最后，核心 Promises/A+ 规范不涉及如何创建、fulfill或rejected你的promise对象，而是选择专注于提供可互操作的 <code>then</code> 方法。伴随规范的未来工作可能会涉及这些主题。</p><h2 id="1-Terminology"><a href="#1-Terminology" class="headerlink" title="1.Terminology"></a>1.Terminology</h2><ul><li>“promise”是具有 then 方法的对象或函数，其行为符合本规范。</li><li>“thenable”是定义 then 方法的对象或函数。</li><li>“value”是任何合法的 JavaScript 值（包括 undefined、thenable 或 promise）。</li><li>“异常”是使用 throw 语句抛出的值。</li><li>“reason”是一个值，表示Promise被rejected的原因。</li></ul><h2 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2.Requirements"></a>2.Requirements</h2><h3 id="2-1-Promise-States"><a href="#2-1-Promise-States" class="headerlink" title="2.1 Promise States"></a>2.1 Promise States</h3><p>承诺必须处于以下三种状态之一：pending（待定）、fulfilled（已完成）或rejected（被拒绝）。</p><blockquote><p>在下文中，这三个名词会使用英文单词而非翻译，方便区分</p></blockquote><ul><li>当处于pending状态时，promise 可以转换到fulfilled或rejected状态。</li><li>当处于fulfilled状态时，promise不能转化到其他状态，必须有一个值(value)，且不能被改变。</li><li>当处于rejected状态时，promise不能转化到其他状态，必须有一个理由(reason)，且不能被改变</li></ul><p>在这里，“不得改变”意味着不变的内存地址（即 ===），但并不意味着更深层次的不变性。（例如对象和数组）</p><h3 id="2-2-The-then-Method"><a href="#2-2-The-then-Method" class="headerlink" title="2.2 The then Method"></a>2.2 The <code>then</code> Method</h3><p>Promise 必须提供 then 方法来访问其当前或最终value或reason。</p><p>一个 promise 的 then 方法接受两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ul><li><p>onFulfilled 和 onRejected 都是可选参数：</p><ul><li><p>如果onFulfilled不是方法，他必须被忽略</p></li><li><p>如果onRejected不是方法，他必须被忽略</p></li></ul></li><li><p>如果onFulfilled是方法</p><ul><li>必须在 promise 完成后调用它，promise 的值作为它的第一个参数。</li><li>在 promise 完成之前不能调用它。</li><li>它不能被多次调用。</li></ul></li><li><p>如果onRejected是方法</p><ul><li>必须在 promise 被拒绝后调用它，promise 的reason作为它的第一个参数。</li><li>在 promise 被拒绝之前不能调用它。</li><li>它不能被多次调用。</li></ul></li><li><p>在执行上下文堆栈仅包含<strong>平台代码</strong>之前，不得调用 onFulfilled 或 onRejected。 [3.1]。</p></li></ul><blockquote><p>onFulfilled和onRejected方法必须异步调用</p></blockquote><ul><li>then 可以在同一个 promise 上多次调用。<ul><li>如果/当promise转化为fulfilled，所有相应的 onFulfilled 回调必须按照它们对 then 的原始调用的顺序执行。</li><li>如果/当promise转化为rejected状态，所有相应的 onRejected 回调必须按照它们对 then 的原始调用的顺序执行。</li></ul></li><li>then必须返回一个promise。<code>promise2 = promise1.then(onFulfilled, onRejected);</code><ul><li>如果 onFulfilled 或 onRejected 返回了一个值 x，则运行 Promise Resolution Procedure [[Resolve]](promise2, x)。</li><li>如果 onFulfilled 或 onRejected 抛出异常 e，promise2 必须以 e 作为reason并转化到rejected状态。</li><li>如果 onFulfilled 不是函数并且 promise1 已实现，则 promise2 必须以与 promise1 相同的value并转化到fulfilled状态。</li><li>如果 onRejected 不是函数并且 promise1 处于rejected状态，则 promise2 必须以与 promise1 相同的reason并转化到rejected状态。</li></ul></li></ul><h3 id="2-3-The-Promise-Resolution-Procedure"><a href="#2-3-The-Promise-Resolution-Procedure" class="headerlink" title="2.3 The Promise Resolution Procedure"></a>2.3 The Promise Resolution Procedure</h3><p><strong>promise resolution procedure</strong> 是一个抽象操作，将promise和value作为输入，我们将其表示为<code> [[Resolve]](promise, x)</code>。如果 x 是一个 thenable，或者它的 x 的行为至少有点像 promise，它会尝试让 promise 采用 x 的状态。否则，他会把promise以x作为值并将其转化为fulfilled状态。</p><p>这种对 thenables 的处理允许 promise 实现互操作，只要它们公开一个符合 Promises/A+ 的 then 方法。它还允许 Promises/A+ 实现运用合理的 then 方法“同化”不一致的实现。</p><p>要运行<code> [[Resolve]</code>](promise, x)，请执行以下步骤：</p><ul><li>如果 promise 和 x 引用同一个对象，则以 TypeError 作为原因拒绝 promise。</li><li>如果 x 是一个承诺，采用它的状态 [3.4]<ul><li>如果 x 是挂起的，promise 必须保持挂起直到 x 被完成或拒绝。</li><li>如果/当 x 完成时，用相同的值完成promise。</li><li>如果/当 x 被拒绝时，以同样的理由拒绝promise。</li></ul></li><li>否则，如果 x 是一个对象或函数<ul><li>让then变成x.then [3.5]</li><li>如果检索属性 x.then 导致抛出异常 e，则以 e 为原因拒绝 promise。</li><li>如果 then 是一个函数，则使用 x 作为 this 调用它，第一个参数是 resolvePromise，第二个参数是 rejectPromise，其中：<ul><li>如果/当使用值 y 调用 resolvePromise 时，运行 <code>[[Resolve]](promise, y)</code>。</li><li>如果/当以原因 r 调用 rejectPromise，则用 r 拒绝 promise。</li><li>如果同时调用了 resolvePromise 和 rejectPromise，或者对同一个参数进行了多次调用，则第一个调用优先，任何进一步的调用都将被忽略。</li><li>如果调用然后抛出异常 e：如果调用了 resolvePromise 或 rejectPromise ，则忽略它。其他情况，使用理由e拒绝promise</li></ul></li></ul></li><li>如果 x 不是对象或函数，使用x将promise转化为fulfilled状态。</li></ul><p>如果一个 promise 用一个 thenable 解决，该 thenable 参与循环 thenable 链，这样 [[Resolve]](promise, thenable) 的递归性质最终会导致<code>[[Resolve]](promise, thenable)</code>再次被调用，如下上述算法会导致无限递归。鼓励但不要求实现来检测这种递归并拒绝以信息丰富的 TypeError 作为原因的承诺。 [3.6]</p><h2 id="3-Notes"><a href="#3-Notes" class="headerlink" title="3. Notes"></a>3. Notes</h2><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>这里的“平台代码”是指引擎、环境和promise实现代码。在实践中，这个要求确保 onFulfilled 和 onRejected 异步执行，在调用 then 的事件循环之后，并使用新的堆栈。这可以通过“宏任务”机制（例如 setTimeout 或 setImmediate）或“微任务”机制（例如 MutationObserver 或 process.nextTick）来实现。由于promise实现被认为是平台代码，它本身可能包含一个任务调度队列或“trampoline”，在其中调用处理程序。</p><h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><p>也就是说，在严格模式下，这在它们内部是未定义的；在草率模式下，它将是全局对象。</p><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>实现可能允许 promise2 === promise1，前提是实现满足所有要求。每个实现都应该记录它是否可以产生 promise2 === promise1 以及在什么条件下。</p><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>一般来说，只有当 x 来自当前的实现时，才会知道 x 是一个真正的承诺。该条款允许使用特定于实现的手段来采用已知符合承诺的状态。</p><h4 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h4><p>首先存储对 x.then 的引用，然后测试该引用，然后调用该引用的过程避免了对 x.then 属性的多次访问。这些预防措施对于确保访问器属性的一致性很重要，访问器属性的值可能会在检索之间发生变化。</p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h4><p>实现不应对 thenable 链的深度设置任意限制，并假设超出该任意限制递归将是无限的。只有真正的循环才会导致 TypeError；如果遇到无限的不同 thenable 链，则永远递归是正确的行为。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从这里开始</title>
      <link href="/2021/09/14/first-blog/"/>
      <url>/2021/09/14/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="从这里开始"><a href="#从这里开始" class="headerlink" title="从这里开始"></a>从这里开始</h1><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210914213620578.png" alt="image-20210914213620578"></p><p>今天是9月14日，一个平平无奇的日子，大学时光已经距离我远去将近一年了。我也成为了大街上的众多来来往往的“社会人”之一。但我是从来把这些经历都看做是每一个地图、每一个阶段，没有珍贵和可惜、没有难受的心情，没有世事纷杂，每个阶段都有我引以为豪的经历、有珍惜和不珍惜的朋友、有遗憾和感伤、幸福和忧愁，但是终于我走到了这个阶段。</p><p>熟悉了半年的工作，逐渐适应了这个身份。逐渐变得更加率真、冷静、精炼、肥胖、熟练、认命、不屈。时好时坏，总之开始摸到门路，工作前的不自信和重重顾虑像键盘上的钢琴烤漆一样被时间磨的干干净净，习惯像每天涂的啫喱一样厚厚的、锃光瓦亮且难以割舍。</p><p>选择前端有很多理由，最好不过对<strong>Visual Studio Code</strong>这款编辑器的喜爱，在学生时代用丑丑的Visual Basic、Sublime、Eclipse然后第一次用它简直惊为天人。颜值真的很高很高。此外可能是虽然我其他编程科目也很高，但就前端这一门学的最好，做的课设还被老师给下一届的学弟学妹宣传看看，可以说很自豪了（虽然现在看起来真的很简单很简单…）总之，前端的反馈感真的很不赖。</p><p><img src="https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/u=1729656421,1663042930&fm=15&fmt=auto&gp=0.jpg" alt="img"></p><p>虽然目前还是菜鸟，希望能继续进步吧…感觉光这一个领域就够研究一辈子的了（人类果然还是渺小的）。</p><p>PS：自己虽然是肥宅但是是很喜欢新事物的（譬如旅游）。</p><p>当然，money不够那就是另一回事了…</p><blockquote><p>此篇尽量避免了当下的网络流行用语，防止多年以后看不懂</p></blockquote><blockquote><p>最近在看《半泽直树》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
